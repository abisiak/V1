-- Auto-parry + Lock-On integrados (un solo LocalScript)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
-- helper: devuelve true si el jugador está en "hybrid" (si existe states.Transformed)
local function isPlayerHybrid()
	local states = LocalPlayer:FindFirstChild("states")
	if not states then return false end
	-- sólo por existencia (como pediste)
	local transformed = states:FindFirstChild("Transformed")
	return transformed ~= nil
end

-- Helpers defensivos
local clamp = math.clamp or function(x, a, b) return math.max(a, math.min(b, x)) end

-- HRP seguro
local function getHRP()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	return char:WaitForChild("HumanoidRootPart")
end

local HRP = nil
if LocalPlayer.Character then
	local ok, p = pcall(function() return getHRP() end)
	if ok then HRP = p end
end

-- cacheo de remotes
local eventsFolder = ReplicatedStorage:WaitForChild("events")
local remotes = {
	remote = eventsFolder:WaitForChild("remote"),
	toolremote = eventsFolder:WaitForChild("toolremote"),
}

-- Tabla de reacciones (pon aquÃ­ tus configs)
-- Puede ser: animationReactions[id] = { key="F", delay=0, range={min=0,max=12} }
-- o bien: animationReactions[id] = { {key="F", ...}, {key="lock", priority=10, lockDuration=1, ...} }
local animationReactions = {
        --kon     
	["12177079842"] = { key = "hammer", delay = 0, range = {min = 10, max = 50} },
        --scyte(normal)
	["12505816013"] = { key = "F", delay = 0, range = {min = 0, max = 23}, rv = false },
--knife E
	["7568108641"] = { key = "F", delay = 0, range = {min = 0, max = 15}, rv = false },
-- axe kick
	["12483737431"] = { key = "F", delay = 0.2, range = {min = 0, max = 13} },
--thermal x1
	["15404604913"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--claw
	["13487211959"] = { key = "F", delay = 0, range = {min = 0, max = 19}, rv = false},
--thermal x2
	["15404609840"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--thermal x3
	["15404615382"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--katana m2
	["8179748204"] = { key = "F", delay = 0.3, range = {min = 0, max = 23}, rv = false },
--karambit x1
	["15414582390"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--karambit x2
	["15414585949"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--karambit x3
	["15430111795"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--fists x1
	["12373722677"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--fists x2
	["12373744698"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--fists x3
	["12374008952"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--fists x4
	["12690107981"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--deep sea x1
	["16024193549"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--deep sea x2
	["16024282314"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--deep sea x3
	["16024897725"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--chainsaw x1
	["12539917297"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--chainsaw x2
	["12539924939"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--chainsaw x3
	["12539907543"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--bomb x3
	["12539896513"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--shark r
["108740270242172"] = { key = "Q", delay = 0, range = {min = 0, max = 40}, rv = false },
--shark chaw
	["130481997116962"] = { key = "F", delay = 0, range = {min = 1, max = 27}, rv = false },
--bomb x?
	["12641658796"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--bomb x?
	["12641656228"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--chainsaw m2
	["11916882700"] = { key = "F", delay = 0.2, range = {min = 1, max = 27}, rv = false },
--chainsaw Z
	["12630461862"] = { key = "F", delay = 0.4, range = {min = 0, max =170} },
--axe x1
	["12694331871"] = { key = "F", delay = 0.1, range = {min = 0, max = 9.5}, rv = false },
--knife/karambit m2
	["7393178909"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--axe x2
	["12694448884"] = { key = "F", delay = 0.1, range = {min = 0, max = 9.5}, rv = false },
--deep sea E
	["16033074314"] = { key = "Q", delay = 0.1, range = {min = 0, max = 15} },
--axe x3
	["12702771654"] = { key = "F", delay = 0.2, range = {min = 0, max = 9.5} },
--axe x4
	["12703011805"] = { key = "F", delay = 0.2, range = {min = 0, max = 9.5} },
--axe m2
	["12702972513"] = { key = "F", delay = 0.2, range = {min = 0, max = 9.5} },
--sledgehammer x1
	["15430188883"] = { key = "F", delay = 0.1, range = {min = 0, max = 9.5} },
--sledgehammer x2
	["15430192542"] = { key = "F", delay = 0.1, range = {min = 0, max = 9.6} },
--sledgehammer x3
	["15430196462"] = { key = "F", delay = 0.1, range = {min = 0, max = 9.6} },
--sledgehammer m2
	["15581919407"] = { key = "F", delay = 0.2, range = {min = 0, max = 10}, rv = false },
--axe E
	["15050129951"] = { key = "Q", delay = 0, range = {min = 0, max = 15}, rv = false },
--choke
	["11740370682"] = { key = "Q", delay = 0, range = {min = 0, max = 30}, rv = false },
--katana x1
	["8121978139"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--katana x2
	["8122021891"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--katana x3
	["8122080110"] = { key = "F", delay = 0, range = {min = 0, max = 11.5} },
--katana E
	["12266569143"] = { key = "Q", delay = 0.2, range = {min = 0, max = 18}, rv = false },
-- nail m2
	["11725550905"] = { key = "F", delay = 0.2, range = {min = 0, max = 25} },
-- nail x1
	["12196524051"] = { key = "F", delay = 0, range = {min = 0, max = 17} },
--nail x2
	["12196677030"] = { key = "F", delay = 0, range = {min = 0, max = 16} },
--nail x3
	["12196631889"] = { key = "F", delay = 0, range = {min = 0, max = 16} },
--katanaman z
	["12583743676"] = { key = "F", delay = 0.3, range = {min = 0, max = 23}, rv = false },
--chainsaw E
	["12164877686"] = { key = "Q", delay = 0.3, range = {min = 0, max = 100}, rv = false },
--katana m2
	["8179748204"] = { key = "F", delay = 0.3, range = {min = 0, max = 23} },
--katanaman m2
	["11718800360"] = { key = "F", delay = 0.3, range = {min = 0, max = 80} },
--katanaman x?
	["12536641543"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--katanaman x?
	["12536648018"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--katanaman x1
	["12536618082"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--Parykicks
	["11412413067"] = { key = "m1", delay = 0.18, range = {min = 0, max = 30}, localAllowed = true , rv = false},
	["11367862252"] = { key = "m1", delay = 0.18, range = {min = 0, max = 30}, localAllowed = true , rv = false},
	["8544289138"] = { key = "m1", delay = 0.18, range = {min = 0, max = 30}, localAllowed = true , rv = false},
-- ghost punch
	["11805720948"] = { key = "Q", delay = 0.4, range = {min = 0, max = 28}, rv = false },
--bomb X
	["14990664859"] = { key = "F", delay = 0, range = {min = 0, max = 60}, rv = false },
--m2 fits
	["6819033860"] = { key = "F", delay = 0.1, range = {min = 0, max = 12.5}, rv = false },
        ["6819010188"] = { key = "F", delay = 0.1, range = {min = 0, max = 12.5}, rv = false },
        ["6819068355"] = { key = "F", delay = 0.1, range = {min = 0, max = 12.5}, rv = false },
--E fists
        ["12258987934"] = { key = "Q", delay = 0, range = {min = 0, max = 12.5}, rv = false },
	-- hammer
	["12502854533"] = { key = "Q", delay = 0.7, range = {min = 8, max = 45} },

	-- thunder
	["140319778701762"] = { key = "Q", delay = 0.3, range = {min = 0, max = 35}, rv = false },

	-- feather
	["133128238639970"] = { key = "F", delay = 0.2, range = {min = 0, max = 30}, rv = false },

	-- angel blast
	["75241769652180"] = { key = "Q", delay = 0.3, range = {min = 10, max = 58}, rv = false },

	-- shark bite
	["15503208663"] = { key = "F", delay = 0, range = {min = 0, max = 13} },

	-- axe kickV
	["13288894402"] = { key = "F", delay = 0.3, range = {min = 0, max = 35} },
	
	-- chain
	["121804333140421"] = { key = "F", delay = 0.2, range = {min = 0, max = 50}, rv = false },

	-- shield m1x1
	["87443479643080"] = { key = "F", delay = 0.2, range = {min = 0, max = 12} },

	-- shield m1x2
	["117849900104484"] = { key = "F", delay = 0.2, range = {min = 0, max = 12} },

	-- shield m1x3
	["79984916073099"] = { key = "F", delay = 0.2, range = {min = 0, max = 12} },
	-- Bang ðŸ‘»
	["88991840508105"] = { key = "k", delay = 0, range = {min = 0, max = 11}, rv = false },

	-- R shield
	["126438176215231"] = { key = "Q", delay = 0.1, range = {min = 0, max = 35}, rv = false },
}
animationReactions["11412048186"] = {
    { key = "R",   delay = 0.1, range = {min = 0, max = 24}, rv = false, priority = 1 },
    { key = "E", delay = 0.1, range = {min = 0, max = 9},  rv = false, priority = 2, state = "human" },
}
animationReactions["854420980"] = {
    { key = "R",   delay = 0.1, range = {min = 0, max = 24}, rv = false, priority = 1 },  
    { key = "E", delay = 0.1, range = {min = 0, max = 9},  rv = false, priority = 2, state = "human" },
}
animationReactions["8544209804"] = {
    { key = "R",   delay = 0.1, range = {min = 0, max = 24}, rv = false, priority = 1 },
    { key = "E", delay = 0.1, range = {min = 0, max = 9},  rv = false, priority = 2, state = "human" },
}

animationReactions["11367425425"] = {
    { key = "R",   delay = 0.1, range = {min = 0, max = 24}, rv = false, priority = 1 },
    { key = "E", delay = 0.1, range = {min = 0, max = 9},  rv = false, priority = 2, state = "human" },
}

animationReactions["5502444144"] = {
    { key = "k",   delay = 0.3, range = {min = 0, max = 10}, rv = false },
    { reaction = "lock", delay = 0, range = {min = 0, max = 20}, rv = false },
    { key = "E", delay = 0.1, range = {min = 0, max = 20},  rv = false, priority = 2, state = "hybrid" },
}

animationReactions["5502635805"] = {
    { key = "k",   delay = 0.3, range = {min = 0, max = 10}, rv = false },
    { reaction = "lock", delay = 0, range = {min = 0, max = 20}, rv = false },
  { key = "E", delay = 0.1, range = {min = 0, max = 20},  rv = false, priority = 2, state = "hybrid" },
}

animationReactions["5502286572"] = {
    { key = "k",   delay = 0.3, range = {min = 0, max = 10}, rv = false },
    { reaction = "lock", delay = 0, range = {min = 0, max = 20}, rv = false },
  { key = "E", delay = 0.1, range = {min = 0, max = 20},  rv = false, priority = 2, state = "hybrid" },
}

animationReactions["5502543898"] = {
    { key = "k",   delay = 0.3, range = {min = 0, max = 10}, rv = false },
    { reaction = "lock", delay = 0, range = {min = 0, max = 20}, rv = false },
  { key = "E", delay = 0.1, range = {min = 0, max = 20},  rv = false, priority = 2, state = "hybrid" },
}

-- Redirect R->F si se activa
local redirectAnimations = {
	["11412048186"] = true,
	["854420980"] = true,
	["8544209804"] = true,
	["11367425425"] = true,
}
local redirectRtoF = false

-- Key actions (usa remotes cacheadas)
local keyActions = {
	F = function()
		remotes.remote:FireServer("Parry")
	end,
	Q = function()
		remotes.remote:FireServer("Dash", "W", "NoTorsoRotate")
	end,
	R = function()
		remotes.remote:FireServer("StrongAttack")
	end,
	E = function()
		remotes.remote:FireServer("Skill1")
	end,
	k = function()
		remotes.toolremote:FireServer("Bang")
	end,
        axe = function()
		remotes.toolremote:FireServer("Claw Slash")
	end,
	m1 = function()
		remotes.remote:FireServer("NormalAttack")
		redirectRtoF = true
		task.delay(0.5, function()
			redirectRtoF = false
		end)
	end,
	hammer = function()
		remotes.toolremote:FireServer("Blood Hammer Slam")
	end,
}

-- Cooldowns por jugador+id (manteniÃ©ndose compatible)
local recentReactions = {}
local autoParryEnabled = true

local function getMaxAngleForDistance(distance)
	if distance < 1.5 then return 180 end -- skip
	if distance < 5 then return 75 end
	if distance < 10 then return 75 end
	if distance < 15 then return 90 end
	if distance < 25 then return 150 end
	return 170
end

-- GUI (un solo ScreenGui con TextBox/Lock button y Auto-parry toggle)
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AutoParryGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

-- Lock-On TextBox (arriba izquierda)
local LockTextBox = Instance.new("TextBox")
LockTextBox.Size = UDim2.new(0, 200, 0, 30)
LockTextBox.Position = UDim2.new(0, 10, 0, 10)
LockTextBox.Parent = screenGui

-- Lock-On Toggle Button (debajo del TextBox)
local LockButton = Instance.new("TextButton")
LockButton.Size = UDim2.new(0, 200, 0, 30)
LockButton.Position = UDim2.new(0, 10, 0, 50)
LockButton.Text = "ðŸ“ Lock-On OFF"
LockButton.Parent = screenGui

-- Auto-parry toggle (arriba derecha)
local APButton = Instance.new("TextButton")
APButton.Parent = screenGui
APButton.Size = UDim2.new(0, 140, 0, 38)
APButton.Position = UDim2.new(1, -150, 0, 5)
APButton.Text = "Auto-parry: ON"
APButton.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
APButton.TextColor3 = Color3.new(1, 1, 1)
APButton.Font = Enum.Font.SourceSansBold
APButton.TextSize = 20
APButton.BorderSizePixel = 0

APButton.MouseButton1Click:Connect(function()
	autoParryEnabled = not autoParryEnabled
	APButton.Text = "Auto-parry: " .. (autoParryEnabled and "ON" or "OFF")
	APButton.BackgroundColor3 = autoParryEnabled and Color3.fromRGB(0, 150, 0) or Color3.fromRGB(150, 0, 0)
end)

-- Lock-on internals
local camera = workspace.CurrentCamera
-- Forzar refresh de cámara (arregla comportamiento con ShiftLock)
local function refreshCamera()
	-- lo hacemos en un hilo para no bloquear
	task.spawn(function()
		local cam = workspace.CurrentCamera
		-- seguridad
		if not LocalPlayer or not LocalPlayer.Character then return end
		local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
		if not humanoid then return end

		-- reset temporal del CameraSubject para forzar recalculo
		pcall(function()
			cam.CameraSubject = nil
			-- espera un frame corto para que el engine aplique el cambio
			task.wait()
			cam.CameraSubject = humanoid
		end)
	end)
end
local cameraOffset = Vector3.new(5, 8, 15)
local targetPlayer = nil
local isLockOnActive = false

local function findClosestMatch(name)
	if not name or name == "" then return nil end
	name = name:lower()
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Name:lower():sub(1, #name) == name then
			return player
		end
	end
	return nil
end

local function activateLockByName(name, duration)
	-- si no se pasa nombre, tomamos el contenido del LockTextBox
	local nameToUse = name
	if not nameToUse or nameToUse == "" then
		nameToUse = LockTextBox.Text
	end
	if not nameToUse or nameToUse == "" then return end

	local found = findClosestMatch(nameToUse)
	if not found then return end

	targetPlayer = found
	isLockOnActive = true
	LockButton.Text = "âŒ Lock-On ON"
	-- planear desactivaciÃ³n
	task.delay(duration or 1.5, function()
	if isLockOnActive and targetPlayer == found then
		isLockOnActive = false
		targetPlayer = nil
		LockButton.Text = "📍 Lock-On OFF"
		-- forzar refresh aquí también (por si el lock caduca)
		refreshCamera()
	end
end)
end

local function deactivateLock()
	isLockOnActive = false
	targetPlayer = nil
	LockButton.Text = "📍 Lock-On OFF"

	-- forzar refresh de cámara (soluciona shiftlock)
	refreshCamera()
end

-- Toggle manual del botÃ³n
LockButton.MouseButton1Click:Connect(function()
	local nameInput = LockTextBox.Text
	if not isLockOnActive then
		local foundPlayer = findClosestMatch(nameInput)
		if foundPlayer then
			targetPlayer = foundPlayer
			isLockOnActive = true
			LockButton.Text = "âŒ Lock-On ON"
			print("Lock-On activado en", targetPlayer.Name)
		else
			warn("No se encontrÃ³ un jugador con ese nombre.")
		end
	else
		deactivateLock()
		print("Lock-On desactivado")
	end
end)

-- RotaciÃ³n / cÃ¡mara del lock-on (RenderStepped)
RunService.RenderStepped:Connect(function()
	if isLockOnActive 
		and targetPlayer 
		and targetPlayer.Character 
		and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
		and LocalPlayer.Character 
		and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then

		local root = LocalPlayer.Character.HumanoidRootPart
		local targetRoot = targetPlayer.Character.HumanoidRootPart

		-- RotaciÃ³n del personaje hacia el objetivo (horizontal)
		local targetPos = targetRoot.Position
		local selfPos = root.Position
		local direction = (Vector3.new(targetPos.X, selfPos.Y, targetPos.Z) - selfPos).Unit
		root.CFrame = CFrame.new(selfPos, selfPos + direction)

		-- CÃ¡mara con offset
		local camPos = root.Position + (root.CFrame:VectorToWorldSpace(cameraOffset))
		camera.CFrame = CFrame.new(camPos, targetRoot.Position)
	else
		-- Si targetPlayer ya no es vÃ¡lido, apaga el lock-on automÃ¡ticamente
		if isLockOnActive then
			isLockOnActive = false
			targetPlayer = nil
			LockButton.Text = "ðŸ“ Lock-On OFF"
		end
	end
end)

-- ==== Reacciones: validaciÃ³n / ejecuciÃ³n (multi-config + lock reaction) ====

local function getEffectiveKey(id, originalKey)
	if redirectRtoF and originalKey == "R" and redirectAnimations[id] then
		return "F"
	end
	return originalKey
end
local function isValidReaction(player, id, distance, isLocal, enemyHRP, config)
	if not config then return false end

	if config.localAllowed and not isLocal then return false end
	if not config.localAllowed and isLocal then return false end

	if not HRP or not HRP.Parent then return false end
	if not enemyHRP or not enemyHRP.Parent then return false end

	-- rango (defaults seguros)
	local rmin = (config.range and config.range.min) or 0
	local rmax = (config.range and config.range.max) or math.huge
	if distance < rmin or distance > rmax then return false end

	-- estado humano / hybrid
	if config.state then
		local hybrid = isPlayerHybrid()
		if config.state == "hybrid" and not hybrid then return false end
		if config.state == "human" and hybrid then return false end
	end

	-- === PARCHE DEFINITIVO DE COOLDOWN ===
	local identifier = "unknown"

	if typeof(player) == "Instance" then
		if player:IsA("Player") then
			identifier = "PLR_" .. tostring(player.UserId)
		elseif player:IsA("Model") then
			identifier = "NPC_" .. (player.Name or "Unnamed")
		else
			identifier = "OBJ_" .. player.ClassName
		end
	else
		identifier = tostring(player)
	end

	local key = identifier .. ":" .. id

	if recentReactions[key] and tick() - recentReactions[key] < (config.delay or 0) then
		return false
	end
	-- === FIN DEL PARCHE ===

	-- visión angular
	if config.rv ~= false and distance >= 2 then
		local maxAngle = getMaxAngleForDistance(distance)
		local enemyLookVector = enemyHRP.CFrame.LookVector
		local dirVec = HRP.Position - enemyHRP.Position
		if dirVec.Magnitude ~= 0 then
			local directionToMe = dirVec.Unit
			local dot = clamp(enemyLookVector:Dot(directionToMe), -1, 1)
			local angleDegrees = math.deg(math.acos(dot))
			if angleDegrees > maxAngle then
				return false
			end
		end
	end

	return true
end


-- react ahora acepta config y maneja "lock" como reacciÃ³n
local function react(player, id, config)
	if not config then return end
	local keyToUse = getEffectiveKey(id, config.key or config.reaction)

	-- cooldown por jugador+id
-- cooldown por jugador+id (compatible con NPCs)
local identifier = "unknown"

if typeof(player) == "Instance" then
	if player:IsA("Player") then
		identifier = "PLR_" .. tostring(player.UserId)
	elseif player:IsA("Model") then
		identifier = "NPC_" .. (player.Name or "Unnamed")
	else
		identifier = "OBJ_" .. player.ClassName
	end
else
	identifier = tostring(player)
end

local reactionKey = identifier .. ":" .. id
recentReactions[reactionKey] = tick()

	task.delay(config.delay or 0, function()
		if keyToUse == "lock" then
			local nameArg = nil
			if config.lockName and type(config.lockName) == "string" and config.lockName ~= "" then
				nameArg = config.lockName
			end
			activateLockByName(nameArg, config.lockDuration or 1.3)
			return
		end

		-- ✅ usar keyToUse
		local action = keyActions[keyToUse]
		if action then
			action()
		else
			warn("No hay acción para la key:", tostring(keyToUse), "en id", id)
		end
	end)
end

_G.autoParryEnabled = autoParryEnabled

local function onAnimationPlayed(track, owner, isLocal, player)
    if not _G.autoParryEnabled then return end
    if not track or not track.Animation or not track.Animation.AnimationId then return end

    local id = track.Animation.AnimationId:match("%d+")
    if not id then return end

    -- owner puede ser un Humanoid (cuando lo llamas desde humanoid.AnimationPlayed)
    -- o el Model/Character (cuando lo llamas desde Animator.AnimationPlayed)
    local character
    if owner and owner.IsA and owner:IsA("Humanoid") then
        character = owner.Parent
    elseif owner and owner.IsA and owner:IsA("Model") then
        character = owner
    end

    local targetHRP = character and character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return end


	-- asegurarnos HRP local existe
	if not HRP or not HRP.Parent then
		return
	end

	-- distancia segura
	local ok, distance = pcall(function()
		return (HRP.Position - targetHRP.Position).Magnitude
	end)
	if not ok or not distance then return end

	local configs = animationReactions[id]
	if not configs then return end

	-- normalizar configs a lista
	local list = {}
	if type(configs) == "table" and configs[1] then
		-- es array-like
		for _, v in ipairs(configs) do table.insert(list, v) end
	else
		-- single object (compatibilidad)
		table.insert(list, configs)
	end

	-- filtrar vÃ¡lidos
	local valid = {}
	for _, cfg in ipairs(list) do
		if isValidReaction(player, id, distance, isLocal, targetHRP, cfg) then
			table.insert(valid, cfg)
		end
	end
	if #valid == 0 then return end

	-- decidir ejecuciÃ³n: si hay prioridades, ordenar; siempre ejecutar todas en orden
table.sort(valid, function(a, b)
	return (a.priority or 0) > (b.priority or 0)  -- mayor primero
end)

for _, v in ipairs(valid) do
	react(player, id, v)
end
end
-- === Monitorizado de jugadores y humanoids (limpieza de conexiones) ===
local connections = {} -- clave: tostring(player.UserId)

local function makeKeyForPlayer(player)
	if typeof(player) == "Instance" then
		if player:IsA("Player") then
			return "PLR_" .. tostring(player.UserId)
		elseif player:IsA("Model") then
			return "NPC_" .. (player.Name or "Unnamed")
		else
			return "OBJ_" .. player.ClassName
		end
	end
	return tostring(player)
end


local function connectAnimatorToPlayer(key, character, animator, player, isLocal)
	if not animator or not animator:IsA("Animator") then return end
	-- evitar doble conexión si el Animator es el del Humanoid (lo manejamos con humanoid.AnimationPlayed)
	if animator.Parent and animator.Parent:IsA("Humanoid") then return end

	local conn = animator.AnimationPlayed:Connect(function(track)
		-- pasamos 'character' como referencia del objetivo
		onAnimationPlayed(track, character, isLocal, player)
	end)

	-- asegurar tabla
	connections[key].animConns = connections[key].animConns or {}
	table.insert(connections[key].animConns, conn)
end

local function monitorCharacter(player, character, isLocal)
	if not player or not character then return end
	local key = makeKeyForPlayer(player)

	-- limpiar conexiones previas (si las hay)
	if connections[key] then
		-- desconectar todas las animConns previas
		if connections[key].animConns then
			for _, c in ipairs(connections[key].animConns) do
				if c and c.Disconnect then pcall(c.Disconnect, c) end
			end
		end
		-- desconectar childAdded / ancestry previos
		if connections[key].childAddedConn then pcall(connections[key].childAddedConn.Disconnect, connections[key].childAddedConn) end
		if connections[key].ancestryConn then pcall(connections[key].ancestryConn.Disconnect, connections[key].ancestryConn) end
	end

	-- inicializar estructura
	connections[key] = connections[key] or {}
	connections[key].animConns = {}

	-- esperar humanoid (si no existe, esperar un poco)
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		humanoid = character:WaitForChild("Humanoid", 3)
		if not humanoid then
			-- aun si no hay Humanoid (caso raro), seguimos intentando detectar animators del modelo (p.ej. SharkDevil)
		end
	end

	-- conectar AnimationPlayed del Humanoid (si existe)
	if humanoid then
		local hconn = humanoid.AnimationPlayed:Connect(function(track)
			-- pasamos 'character' como referencia del objetivo
			onAnimationPlayed(track, character, isLocal, player)
		end)
		table.insert(connections[key].animConns, hconn)
	end

	-- Conectar todos los Animator / AnimationController existentes dentro del character (p.ej. SharkDevil)
	for _, obj in ipairs(character:GetDescendants()) do
		if obj:IsA("AnimationController") then
			local anim = obj:FindFirstChild("Animator")
			if anim then
				connectAnimatorToPlayer(key, character, anim, player, isLocal)
			end
		elseif obj:IsA("Animator") then
			-- skip humanoid.Animator (lo evitamos dentro de connectAnimatorToPlayer)
			connectAnimatorToPlayer(key, character, obj, player, isLocal)
		end
	end

	-- escuchar ChildAdded para detectar transformaciones (p.ej. SharkDevil añadido)
	connections[key].childAddedConn = character.ChildAdded:Connect(function(child)
		-- si agregan un AnimationController, conectar su Animator cuando aparezca
		if child:IsA("AnimationController") then
			local anim = child:FindFirstChild("Animator") or child:WaitForChild("Animator", 2)
			if anim then
				connectAnimatorToPlayer(key, character, anim, player, isLocal)
			end
		-- si añaden un Animator directamente (poco usual), también conectamos
		elseif child:IsA("Animator") then
			connectAnimatorToPlayer(key, character, child, player, isLocal)
		-- también revisar si un modelo como SharkDevil se añade con Animator dentro (o con AnimationController dentro)
		else
			-- revisar descendientes recién añadidos (un poco más caro pero seguro)
			task.defer(function()
				for _, d in ipairs(child:GetDescendants()) do
					if d:IsA("AnimationController") then
						local anim = d:FindFirstChild("Animator")
						if anim then connectAnimatorToPlayer(key, character, anim, player, isLocal) end
					elseif d:IsA("Animator") then
						connectAnimatorToPlayer(key, character, d, player, isLocal)
					end
				end
			end)
		end
	end)

	-- limpiar cuando el character se pierde (ancestry)
	connections[key].ancestryConn = character.AncestryChanged:Connect(function(_, parent)
		if not parent then
			-- desconectar todo
			if connections[key] then
				if connections[key].animConns then
					for _, c in ipairs(connections[key].animConns) do
						if c and c.Disconnect then pcall(c.Disconnect, c) end
					end
				end
				if connections[key].childAddedConn then pcall(connections[key].childAddedConn.Disconnect, connections[key].childAddedConn) end
				if connections[key].ancestryConn then pcall(connections[key].ancestryConn.Disconnect, connections[key].ancestryConn) end
				connections[key] = nil
			end
		end
	end)
end

-- === Monitorizado de NPCs en workspace.Living ===
local function monitorNPC(npc)
	if not npc or not npc:IsA("Model") then return end
	local npcName = npc.Name
	if not (string.find(npcName, "Fiend") or string.find(npcName, "Devil") or string.find(npcName, "Yakuza") or string.find(npcName, "Hunter") or string.find(npcName, "Devil") or string.find(npcName, "Guy") or string.find(npcName, "Zombie")) then return end

	local key = "NPC_" .. npcName
	connections[key] = connections[key] or {}
	connections[key].animConns = {}

	local humanoid = npc:FindFirstChildOfClass("Humanoid")
	if humanoid then
		local conn = humanoid.AnimationPlayed:Connect(function(track)
			onAnimationPlayed(track, npc, false, npc) -- se usa npc como 'player' simbólico
		end)
		table.insert(connections[key].animConns, conn)
	end

	-- también revisar AnimationControllers
	for _, obj in ipairs(npc:GetDescendants()) do
		if obj:IsA("AnimationController") then
			local anim = obj:FindFirstChild("Animator")
			if anim then
				local conn = anim.AnimationPlayed:Connect(function(track)
					onAnimationPlayed(track, npc, false, npc)
				end)
				table.insert(connections[key].animConns, conn)
			end
		end
	end

	-- limpiar si el NPC muere o se borra
	connections[key].ancestryConn = npc.AncestryChanged:Connect(function(_, parent)
		if not parent then
			if connections[key] then
				for _, c in ipairs(connections[key].animConns) do
					if c and c.Disconnect then pcall(c.Disconnect, c) end
				end
				if connections[key].ancestryConn then pcall(connections[key].ancestryConn.Disconnect, connections[key].ancestryConn) end
				connections[key] = nil
			end
		end
	end)
end


-- Conectar a jugadores existentes
for _, player in ipairs(Players:GetPlayers()) do
	if player ~= LocalPlayer then
		if player.Character then
			monitorCharacter(player, player.Character, false)
		end
		player.CharacterAdded:Connect(function(char)
			task.wait(1)
			monitorCharacter(player, char, false)
		end)
	end
end
-- Conectar a NPCs existentes en workspace.Living
local LivingFolder = workspace:WaitForChild("Living")
for _, npc in ipairs(LivingFolder:GetChildren()) do
	monitorNPC(npc)
end

-- Detectar nuevos NPCs que aparezcan
LivingFolder.ChildAdded:Connect(function(npc)
	task.wait(0.5)
	monitorNPC(npc)
end)

-- PlayerAdded/Removing
Players.PlayerAdded:Connect(function(player)
	if player == LocalPlayer then return end
	player.CharacterAdded:Connect(function(char)
		task.wait(1)
		monitorCharacter(player, char, false)
	end)
	if player.Character then
		monitorCharacter(player, player.Character, false)
	end
end)

Players.PlayerRemoving:Connect(function(player)
    local key = makeKeyForPlayer(player)
    if connections[key] then
        -- desconectar todas animConns guardadas
        if connections[key].animConns then
            for _, c in ipairs(connections[key].animConns) do
                pcall(function() c:Disconnect() end)
            end
        end
        if connections[key].childAddedConn then pcall(function() connections[key].childAddedConn:Disconnect() end) end
        if connections[key].ancestryConn then pcall(function() connections[key].ancestryConn:Disconnect() end) end
        connections[key] = nil
    end
end)


-- Escuchar al jugador local
LocalPlayer.CharacterAdded:Connect(function(char)
	task.wait(1)
	HRP = char:WaitForChild("HumanoidRootPart")
	monitorCharacter(LocalPlayer, char, true)
end)

if LocalPlayer.Character then
	HRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or HRP
	monitorCharacter(LocalPlayer, LocalPlayer.Character, true)
end

-- Detectar manualmente ataques M1 del jugador (por Remote) â€” hook seguro (dejado como tenÃ­as)
local function hookRemotes()
	pcall(function()
		local remote = remotes.remote
		local mt = getrawmetatable(game)
		local oldNamecall = mt.__namecall
		setreadonly(mt, false)

		mt.__namecall = newcclosure(function(self, ...)
			local args = {...}
			local method = getnamecallmethod()

			if self == remote and method == "FireServer" and args[1] == "NormalAttack" then
				redirectRtoF = true
				task.delay(0.5, function()
					redirectRtoF = false
				end)
			end

			return oldNamecall(self, ...)
		end)

		setreadonly(mt, true)
	end)
end

hookRemotes()

-- FIN del script
