-- === KEEP-HOP adentro de APv1 ===
local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local queue = queue_on_teleport
    or (syn and syn.queue_on_teleport)
    or (fluxus and fluxus.queue_on_teleport)

-- Evita duplicar conexiones si reinyectas en el mismo server
if not getgenv().AP_KEEP_INSTALLED then
    getgenv().AP_KEEP_INSTALLED = true

    local function arm()
        if queue then
            queue([[loadstring(game:HttpGet("https://raw.githubusercontent.com/abisiak/V1/refs/heads/main/jijijija"))()]])
        end
    end

    arm()
    if LP and LP.OnTeleport then
        LP.OnTeleport:Connect(arm)
    end
end

-- ======================
-- Script principal
-- ======================
local Players = game:GetService("Players")
local VIM = game:GetService("VirtualInputManager")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Esperar al botón PlayButton
local mainMenu = PlayerGui:WaitForChild("MainMenu")
local menu = mainMenu:WaitForChild("Menu")
local innerMainMenu = menu:WaitForChild("MainMenu")
local playButton = innerMainMenu:WaitForChild("PlayButton")

-- Función genérica: click centro del GUI + offset Y
local function clickGui(guiObj, yOffset)
	if not guiObj then
		warn("GUI nulo")
		return
	end

	-- Por si quieres ver los datos en la consola
	print("ABS POS:", guiObj.AbsolutePosition, "ABS SIZE:", guiObj.AbsoluteSize)

	local absPos = guiObj.AbsolutePosition
	local absSize = guiObj.AbsoluteSize
	local center = absPos + (absSize / 2)

	local x = center.X
	local y = center.Y + (yOffset or 0)

	-- Mover el mouse ahí (algunos juegos lo agradecen)
	VIM:SendMouseMoveEvent(x, y, game)
	task.wait()

	-- Click izquierdo down + up
	VIM:SendMouseButtonEvent(x, y, 0, true, game, 0)
	task.wait()
	VIM:SendMouseButtonEvent(x, y, 0, false, game, 0)
end

-- Esperar un poco a que todo cargue y luego clickear con offset +50 en Y
task.delay(2, function()
	clickGui(playButton, 50)
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local PlaceId = game.PlaceId
local JobId = game.JobId


local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local LivingFolder = workspace:WaitForChild("Living")

-- Remotos
local eventsFolder = ReplicatedStorage:WaitForChild("events")
local remotes = {
    remote = eventsFolder:WaitForChild("remote"),
}

local function doNormalAttack()
    remotes.remote:FireServer("NormalAttack")
end

local function doUnleash()
    -- Lo mismo que tu snippet:
    -- local args = { "Unleash" }
    -- remotes.remote:FireServer(unpack(args))
    remotes.remote:FireServer("Unleash")
end

-- ======================
-- CONFIG
-- ======================

-- Drop de mobs ya tocados
local FARM_POS = Vector3.new(-2507, 945, -38)

-- Caja de ignore (bloque virtual)
local IGNORE_BOX_CENTER = Vector3.new(-2500, 945, -38)        -- centro del bloque
local IGNORE_BOX_HALF_SIZE = Vector3.new(78/2, 13/2, 11/2)    -- (39, 6.5, 5.5)

-- Lugar de reposo
local REST_POS = Vector3.new(-2448, 966, 177)
local REST_INTERVAL = 0.2

local BEHIND_DISTANCE = 4
local SEARCH_INTERVAL = 0.2
local ATTACK_INTERVAL = 0.01
local MAX_FIGHT_TIME = 10

-- Toggle de farmeo (solo TP/ataque; no afecta el server hop)
local AUTO_ENABLED = true

-- El server solo empieza a farmear cuando pase por la secuencia de validación
local SERVER_VALIDATED = false

-- FILTRO FLEXIBLE
local USE_WHITELIST = false

local BLACKLIST = {
    ["NPC"] = true,
    ["Yaksdling"] = true,
}

local WHITELIST = {
    -- ["Specter"]  = true,
    -- ["Specter2"] = true,
}

-- ======================
-- UTILS
-- ======================

local function isInIgnoreBox(worldPos)
    local dx = worldPos.X - IGNORE_BOX_CENTER.X
    local dy = worldPos.Y - IGNORE_BOX_CENTER.Y
    local dz = worldPos.Z - IGNORE_BOX_CENTER.Z
    return math.abs(dx) <= IGNORE_BOX_HALF_SIZE.X
       and math.abs(dy) <= IGNORE_BOX_HALF_SIZE.Y
       and math.abs(dz) <= IGNORE_BOX_HALF_SIZE.Z
end

local function nightExists()
    local gs = workspace:FindFirstChild("GameState")
    return gs and gs:FindFirstChild("Night") ~= nil
end

local function aliveSpectersExist()
    for _, mob in ipairs(LivingFolder:GetChildren()) do
        if mob.Name == "Specter" or mob.Name == "Specter2" then
            local h = mob:FindFirstChildOfClass("Humanoid")
            if h and h.Health > 0 then
                return true
            end
        end
    end
    return false
end

local function hopToRandomServer()
    local servers = {}

    local success, err = pcall(function()
        local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true"):format(PlaceId)
        local res = game:HttpGet(url)
        local body = HttpService:JSONDecode(res)

        if body and body.data then
            for _, v in ipairs(body.data) do
                if type(v) == "table"
                    and tonumber(v.playing)
                    and tonumber(v.maxPlayers)
                    and v.playing < v.maxPlayers
                    and v.id ~= JobId
                then
                    table.insert(servers, v.id)
                end
            end
        end
    end)

    if success and #servers > 0 then
        -- Serverhop "real": otra instancia del mismo juego, no llena y distinta al JobId actual
        TeleportService:TeleportToPlaceInstance(PlaceId, servers[math.random(1, #servers)], LocalPlayer)
    else
        -- Fallback por si la request falla o no encuentra nada
        TeleportService:Teleport(PlaceId, LocalPlayer)
    end
end


-- Referencias al respawn
LocalPlayer.CharacterAdded:Connect(function(char)
    Character = char
    HumanoidRootPart = char:WaitForChild("HumanoidRootPart")
end)

-- FILTRO de mobs válidos (lista negra/blanca + caja ignore + players)
local function isValidMob(model)
    if not model:IsA("Model") then return false end
    if model == Character then return false end
    if Players:GetPlayerFromCharacter(model) then return false end

    local name = model.Name
    if USE_WHITELIST then
        if not WHITELIST[name] then return false end
    else
        if BLACKLIST[name] then return false end
    end

    local humanoid = model:FindFirstChildOfClass("Humanoid")
    local hrp = model:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp or humanoid.Health <= 0 then return false end

    if isInIgnoreBox(hrp.Position) then return false end
    return true
end

local function hasDamageCreditFromPlayer(mob, playerName)
    local dc = mob:FindFirstChild("DamageCredit")
    if not dc then return false end
    for _, child in ipairs(dc:GetChildren()) do
        if child.Name == playerName then
            return true
        end
    end
    return false
end

local function getNextMob()
    local bestMob, bestDist = nil, math.huge
    if not HumanoidRootPart then return nil end
    local myPos = HumanoidRootPart.Position
    for _, mob in ipairs(LivingFolder:GetChildren()) do
        if isValidMob(mob) then
            local hrp = mob:FindFirstChild("HumanoidRootPart")
            if hrp then
                local d = (hrp.Position - myPos).Magnitude
                if d < bestDist then
                    bestDist, bestMob = d, mob
                end
            end
        end
    end
    return bestMob
end

local function tpBehindMob(mob)
    if not HumanoidRootPart then return end
    local hrp = mob:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local mobCF = hrp.CFrame
    local behindPos = mobCF.Position - mobCF.LookVector * BEHIND_DISTANCE
    HumanoidRootPart.CFrame = CFrame.new(behindPos, mobCF.Position)
end

local function handleMob(mob)
    local startTime = tick()
    while AUTO_ENABLED do
        local humanoid = mob:FindFirstChildOfClass("Humanoid")
        local hrp = mob:FindFirstChild("HumanoidRootPart")
        if not humanoid or not hrp or humanoid.Health <= 0 then return end
        if isInIgnoreBox(hrp.Position) then return end

        if hasDamageCreditFromPlayer(mob, LocalPlayer.Name) then
            hrp.CFrame = CFrame.new(FARM_POS)
            return
        end

        tpBehindMob(mob)
        doNormalAttack()

        if tick() - startTime > MAX_FIGHT_TIME then return end
        task.wait(ATTACK_INTERVAL)
    end
end

-- ======================
-- INICIO: reposo + validación de servidor + Unleash
-- ======================

-- Ir a reposo apenas carga
task.defer(function()
    if HumanoidRootPart then
        HumanoidRootPart.CFrame = CFrame.new(REST_POS)
    end
end)

-- Secuencia de validación:
-- 1) Esperar un poco por replicación
-- 2) Si no existe Night -> hop
-- 3) Si existe Night -> 4s spam REST_POS, en el segundo 3 lanza Unleash
task.spawn(function()
    task.wait(0.5) -- margen para que GameState/Night aparezca

    if not nightExists() then
        hopToRandomServer()
        return
    end

    local start = tick()
    local unleashed = false

    while tick() - start < 4 do
        if HumanoidRootPart then
            HumanoidRootPart.CFrame = CFrame.new(REST_POS)
        end

        local elapsed = tick() - start
        if elapsed >= 3 and not unleashed then
            doUnleash()
            unleashed = true
        end

        task.wait(0.1)
    end

    SERVER_VALIDATED = true
end)

-- ======================
-- Supervisor de Night (independiente de AUTO_ENABLED)
-- ======================

local pendingHopWhenClear = false
task.spawn(function()
    local prevNight = nightExists()
    while true do
        local nowNight = nightExists()

        -- Si desaparece Night durante el proceso: marcar hop pendiente
        if (prevNight == true and nowNight == false) then
            pendingHopWhenClear = true
        end
        prevNight = nowNight

        -- Si hay hop pendiente: esperar a que no queden Specter/Specter2 vivos y hacer hop
        if pendingHopWhenClear then
            if not aliveSpectersExist() then
                hopToRandomServer()
                pendingHopWhenClear = false
            end
        end

        task.wait(0.5)
    end
end)

-- ======================
-- Bucle principal (farmeo + reposo)
-- ======================

task.spawn(function()
    while true do
        if HumanoidRootPart then
            -- Si el server aún no está validado: solo reposo
            if not SERVER_VALIDATED then
                HumanoidRootPart.CFrame = CFrame.new(REST_POS)
                task.wait(REST_INTERVAL)
            else
                local mob = AUTO_ENABLED and getNextMob() or nil
                if mob then
                    handleMob(mob)
                else
                    -- sin mobs válidos -> reposo
                    HumanoidRootPart.CFrame = CFrame.new(REST_POS)
                    task.wait(REST_INTERVAL)
                end
            end
        else
            task.wait(0.3)
        end
    end
end)

-- ======================
-- Toggle de farmeo (NO controla hops)
-- ======================
local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.P then
        AUTO_ENABLED = not AUTO_ENABLED
        print("Auto farm (TP/attack):", AUTO_ENABLED and "ON" or "OFF", " — Server hop independiente.")
    end
end)
