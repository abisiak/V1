
-- Auto-parry + Lock-On (LocalScript) - LIMPIO (sin GUI)
-- Conserva conexiones, detección de animaciones y lock-on (controlable por código).
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
-- estado runtime temporal (no lo expongas en la UI)
local redirectUntil = 0

-- =====================
-- Config (editable desde GUI / módulo externo)
-- =====================
local Config = {
    autoParryEnabled = true,
    autoAttackEnabled = true,
    autoParryKickEnabled = true,
    cameraOffset = Vector3.new(3, 8, 15),
    redirectEnabled = false,
    m1AnimationIds = {
    ["7568108641"] = true,
    ["7393166844"] = true,
    ["12003514482"] = true,
    ["7393171468"] = true,
    ["3487211959"] = true,
    ["15404604913"]  = true,
    ["15404609840"]  = true,
    ["15404615382"]  = true,
    ["8179748204"]  = true,
    ["15414582390"]  = true,
    ["15414585949"]  = true,
    ["15430111795"]  = true,
    ["12373722677"]  = true,
    ["12373744698"]  = true,
    ["12374008952"]  = true,
    ["12690107981"]  = true,
    ["16024193549"]  = true,
    ["16024282314"]  = true,
    ["16024897725"]  = true,
    ["12539917297"]  = true,
    ["12539924939"]  = true,
    ["12539907543"]  = true,
    ["12539896513"]  = true,
    ["130481997116962"]  = true,
    ["12641658796"]  = true,
    ["12641656228"]  = true,
    ["11916882700"]  = true,
    ["12630461862"]  = true,
    ["7393178909"]  = true,
    ["12694331871"]  = true,
    ["12694448884"]  = true,
    ["12702771654"]  = true,
    ["12703011805"]  = true,
    ["12702972513"]  = true,
    ["15430188883"]  = true,
    ["15430192542"]  = true,
    ["15430196462"]  = true,
    ["15581919407"]  = true,
    ["8121978139"]  = true,
    ["8122021891"]  = true,
    ["8122080110"]  = true,
    ["11725550905"]  = true,
    ["12196524051"]  = true,
    ["12196677030"]  = true,
    ["12196631889"]  = true,
    ["12583743676"]  = true,
    ["11412413067"]  = true,
    ["11367862252"]  = true,
    ["8544289138"]  = true,
    ["8179748204"]  = true,
    ["12536641543"]  = true,
    ["12536648018"]  = true,
    ["12536618082"]  = true,
    ["87443479643080"]  = true,
    ["117849900104484"]  = true,
    ["79984916073099"]  = true,
    ["11382791600"]  = true,
    },
    redirectAnimations = {
        ["11412048186"] = true,
        ["854420980"] = true,
        ["8544209804"] = true,
        ["11367425425"] = true,
    },
    getMaxAngleForDistance = function(distance)
        if distance < 1.5 then return 180 end
        if distance < 5 then return 75 end
        if distance < 10 then return 75 end
        if distance < 15 then return 90 end
        if distance < 25 then return 150 end
        return 170
    end,
}

-- =====================
-- Servicios / Remotes
-- =====================
local eventsFolder = ReplicatedStorage:WaitForChild("events")
local remotes = {
    remote = eventsFolder:WaitForChild("remote"),
    toolremote = eventsFolder:WaitForChild("toolremote"),
}

-- =====================
-- Helpers
-- =====================
local clamp = math.clamp or function(x, a, b) return math.max(a, math.min(b, x)) end

local function makeIdentifier(obj)
    if typeof(obj) == "Instance" then
        if obj:IsA("Player") then
            return "PLR_" .. tostring(obj.UserId)
        elseif obj:IsA("Model") then
            return "NPC_" .. (obj.Name or "Unnamed")
        else
            return "OBJ_" .. obj.ClassName
        end
    end
    return tostring(obj)
end

local function containerIsTransformed(container)
    if not container or typeof(container) ~= "Instance" then return false end
    local t = container:FindFirstChild("Transformed")
    if not t then return false end
    if t:IsA("BoolValue") then
        return t.Value == true
    end
    return true
end

-- isPlayerHybrid: devuelve true si el player/model/humanoid pasado está 'Transformed'
-- igual que tu versión antigua: true si el jugador local tiene states.Transformed (existencia)
local function isPlayerHybrid()
    local states = LocalPlayer:FindFirstChild("states")
    if not states then return false end
    local transformed = states:FindFirstChild("Transformed")
    return transformed ~= nil
end


-- (Opcional) Mantener compatibilidad con el nombre anterior
isModelHybrid = isPlayerHybrid

local function getCharacterFromOwner(owner)
    if not owner then return nil end
    if typeof(owner) == "Instance" then
        if owner:IsA("Humanoid") and owner.Parent then
            return owner.Parent
        elseif owner:IsA("Model") then
            return owner
        elseif owner:IsA("Animator") and owner.Parent then
            local maybeHum = owner.Parent
            if maybeHum and maybeHum:IsA("Humanoid") and maybeHum.Parent then
                return maybeHum.Parent
            end
            return owner:FindFirstAncestorOfClass("Model")
        end
    end
    return nil
end

-- =====================
-- Reactions table
-- =====================
local animationReactions = {
        --kon     
	["12177079842"] = { key = "hammer", delay = 0, range = {min = 10, max = 50} },
        --scyte(normal)
	["12505816013"] = { key = "F", delay = 0, range = {min = 0, max = 23}, rv = false },
--knife E
	["7568108641"] = { key = "F", delay = 0, range = {min = 0, max = 15}, rv = false },
-- axe kick
	["12483737431"] = { key = "F", delay = 0.2, range = {min = 0, max = 13} },
--thermal x1
	["15404604913"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--claw
	["13487211959"] = { key = "F", delay = 0, range = {min = 0, max = 19}, rv = false},
--thermal x2
	["15404609840"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--thermal x3
	["15404615382"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--katana m2
	["8179748204"] = { key = "F", delay = 0.3, range = {min = 0, max = 23}, rv = false },
--karambit x1
	["15414582390"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--karambit x2
	["15414585949"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--karambit x3
	["15430111795"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--fists x1
	["12373722677"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--fists x2
	["12373744698"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--fists x3
	["12374008952"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--fists x4
	["12690107981"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--deep sea x1
	["16024193549"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--deep sea x2
	["16024282314"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--deep sea x3
	["16024897725"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--chainsaw x1
	["12539917297"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--chainsaw x2
	["12539924939"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--chainsaw x3
	["12539907543"] = { key = "F", delay = 0, range = {min = 0, max = 11} },
--bomb x3
	["12539896513"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--shark r
["108740270242172"] = { key = "Q", delay = 0, range = {min = 0, max = 40}, rv = false },
--shark chaw
	["130481997116962"] = { key = "F", delay = 0, range = {min = 1, max = 27}, rv = false },
--bomb x?
	["12641658796"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--bomb x?
	["12641656228"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--chainsaw m2
	["11916882700"] = { key = "F", delay = 0.2, range = {min = 1, max = 27}, rv = false },
--chainsaw Z
	["12630461862"] = { key = "F", delay = 0.4, range = {min = 0, max =170} },
--axe x1
	["12694331871"] = { key = "F", delay = 0.1, range = {min = 0, max = 9.5}, rv = false },
--knife/karambit m2
	["7393178909"] = { key = "F", delay = 0, range = {min = 0, max = 12} },
--axe x2
	["12694448884"] = { key = "F", delay = 0.1, range = {min = 0, max = 9.5}, rv = false },
--deep sea E
	["16033074314"] = { key = "Q", delay = 0.1, range = {min = 0, max = 15} },
--axe x3
	["12702771654"] = { key = "F", delay = 0.2, range = {min = 0, max = 9.5} },
--axe x4
	["12703011805"] = { key = "F", delay = 0.2, range = {min = 0, max = 9.5} },
--axe m2
	["12702972513"] = { key = "F", delay = 0.2, range = {min = 0, max = 9.5} },
--sledgehammer x1
	["15430188883"] = { key = "F", delay = 0.1, range = {min = 0, max = 9.5} },
--sledgehammer x2
	["15430192542"] = { key = "F", delay = 0.1, range = {min = 0, max = 9.6} },
--sledgehammer x3
	["15430196462"] = { key = "F", delay = 0.1, range = {min = 0, max = 9.6} },
--sledgehammer m2
	["15581919407"] = { key = "F", delay = 0.2, range = {min = 0, max = 10}, rv = false },
--axe E
	["15050129951"] = { key = "Q", delay = 0, range = {min = 0, max = 15}, rv = false },
--choke
	["11740370682"] = { key = "Q", delay = 0, range = {min = 0, max = 30}, rv = false },
--katana x1
	["8121978139"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--katana x2
	["8122021891"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--katana x3
	["8122080110"] = { key = "F", delay = 0, range = {min = 0, max = 11.5} },
--katana E
	["12266569143"] = { key = "Q", delay = 0.2, range = {min = 0, max = 18}, rv = false },
-- nail m2
	["11725550905"] = { key = "F", delay = 0.2, range = {min = 0, max = 25} },
-- nail x1
	["12196524051"] = { key = "F", delay = 0, range = {min = 0, max = 17} },
--nail x2
	["12196677030"] = { key = "F", delay = 0, range = {min = 0, max = 16} },
--nail x3
	["12196631889"] = { key = "F", delay = 0, range = {min = 0, max = 16} },
--katanaman z
	["12583743676"] = { key = "F", delay = 0.3, range = {min = 0, max = 23}, rv = false },
--chainsaw E
	["12164877686"] = { key = "Q", delay = 0.3, range = {min = 0, max = 100}, rv = false },
--katana m2
	["8179748204"] = { key = "F", delay = 0.3, range = {min = 0, max = 23} },
--katanaman m2
	["11718800360"] = { key = "F", delay = 0.54, range = {min = 0, max = 80} },
--katanaman x?
	["12536641543"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--katanaman x?
	["12536648018"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },
--katanaman x1
	["12536618082"] = { key = "F", delay = 0, range = {min = 0, max = 10.5} },

--parrykick
	["11382791600"] = { key = "F", delay = 0, range = {min = 0, max = 40}, rv = false },

--Parykicks
	["11412413067"] = { key = "m1", delay = 0, range = {min = 0, max = 1}, localAllowed = true , rv = false, autoParryKick = true},
	["11367862252"] = { key = "m1", delay = 0, range = {min = 0, max = 1}, localAllowed = true , rv = false, autoParryKick = true},
	["8544289138"] = { key = "m1", delay = 0, range = {min = 0, max = 1}, localAllowed = true , rv = false, autoParryKick = true},

-- ghost punch
	["11805720948"] = { key = "Q", delay = 0.4, range = {min = 0, max = 28}, rv = false },
--bomb X
	["14990664859"] = { key = "F", delay = 0, range = {min = 0, max = 60}, rv = false },
--m2 fits
	["6819033860"] = { key = "F", delay = 0.1, range = {min = 0, max = 12.5}, rv = false },
        ["6819010188"] = { key = "F", delay = 0.1, range = {min = 0, max = 12.5}, rv = false },
        ["6819068355"] = { key = "F", delay = 0.1, range = {min = 0, max = 12.5}, rv = false },
--E fists
        ["12258987934"] = { key = "Q", delay = 0, range = {min = 0, max = 12.5}, rv = false },
	-- hammer
	["12502854533"] = { key = "Q", delay = 0.7, range = {min = 8, max = 45} },

	-- thunder
	["140319778701762"] = { key = "Q", delay = 0.5, range = {min = 0, max = 35}, rv = false },

	-- feather
	["133128238639970"] = { key = "F", delay = 0.2, range = {min = 0, max = 30}, rv = false },

	-- angel blast
	["75241769652180"] = { key = "Q", delay = 0.3, range = {min = 10, max = 58}, rv = false },

	-- shark bite
	["15503208663"] = { key = "F", delay = 0, range = {min = 0, max = 13} },

	-- axe kickV
	["13288894402"] = { key = "F", delay = 0.3, range = {min = 0, max = 35} },
	
	-- chain
	["121804333140421"] = { key = "F", delay = 0.2, range = {min = 0, max = 50}, rv = false },

	-- shield m1x1
	["87443479643080"] = { key = "F", delay = 0.2, range = {min = 0, max = 12} },

	-- shield m1x2
	["117849900104484"] = { key = "F", delay = 0.2, range = {min = 0, max = 12} },

	-- shield m1x3
	["79984916073099"] = { key = "F", delay = 0.2, range = {min = 0, max = 12} },
	-- Bang ðŸ‘»
	["88991840508105"] = { key = "k", delay = 0, range = {min = 0, max = 11}, rv = false },

	-- R shield
	["126438176215231"] = { key = "Q", delay = 0.1, range = {min = 0, max = 35}, rv = false },
}
animationReactions["11412048186"] = {
    { key = "R",   delay = 0, range = {min = 0, max = 24}, rv = false, priority = 1, autoAttack = true },
    { key = "E", delay = 0, range = {min = 0, max = 9},  rv = false, priority = 2, state = "human", autoAttack = true },
}
animationReactions["854420980"] = {
    { key = "R",   delay = 0, range = {min = 0, max = 24}, rv = false, priority = 1, autoAttack = true },  
    { key = "E", delay = 0, range = {min = 0, max = 9},  rv = false, priority = 2, state = "human", autoAttack = true },
}
animationReactions["8544209804"] = {
    { key = "R",   delay = 0, range = {min = 0, max = 24}, rv = false, priority = 1, autoAttack = true },
    { key = "E", delay = 0, range = {min = 0, max = 9},  rv = false, priority = 2, state = "human", autoAttack = true },
}

animationReactions["11367425425"] = {
    { key = "R",   delay = 0, range = {min = 0, max = 24}, rv = false, priority = 1, autoAttack = true },
    { key = "E", delay = 0, range = {min = 0, max = 9},  rv = false, priority = 2, state = "human", autoAttack = true },
}

animationReactions["5502444144"] = {
    { key = "k",   delay = 0.3, range = {min = 0, max = 10}, rv = false, autoAttack = true },
    { reaction = "lock", delay = 0, range = {min = 0, max = 20}, rv = false, autoAttack = true },
    { key = "E", delay = 0.1, range = {min = 0, max = 20},  rv = false, priority = 2, state = "hybrid", autoAttack = true },
}

animationReactions["5502635805"] = {
    { key = "k",   delay = 0.3, range = {min = 0, max = 10}, rv = false, autoAttack = true },
    { reaction = "lock", delay = 0, range = {min = 0, max = 20}, rv = false, autoAttack = true },
  { key = "E", delay = 0.1, range = {min = 0, max = 20},  rv = false, priority = 2, state = "hybrid", autoAttack = true },
}

animationReactions["5502286572"] = {
    { key = "k",   delay = 0.3, range = {min = 0, max = 10}, rv = false, autoAttack = true },
    { reaction = "lock", delay = 0, range = {min = 0, max = 20}, rv = false, autoAttack = true },
  { key = "E", delay = 0.1, range = {min = 0, max = 20},  rv = false, priority = 2, state = "hybrid", autoAttack = true },
}

animationReactions["5502543898"] = {
    { key = "k",   delay = 0.3, range = {min = 0, max = 10}, rv = false, autoAttack = true },
    { reaction = "lock", delay = 0, range = {min = 0, max = 20}, rv = false, autoAttack = true },
  { key = "E", delay = 0.1, range = {min = 0, max = 20},  rv = false, priority = 2, state = "hybrid", autoAttack = true },
}

-- =====================
-- Key actions
-- =====================
local keyActions = {
    F = function() remotes.remote:FireServer("Parry") end,
    FFF = function() remotes.remote:FireServer("Parre") end,
    Q = function() remotes.remote:FireServer("Dash", "W", "NoTorsoRotate") end,
    R = function() remotes.remote:FireServer("StrongAttack") end,
    E = function() remotes.remote:FireServer("Skill1") end,
    k = function() remotes.toolremote:FireServer("Ghost Hand Punch") end,
    axe = function() remotes.toolremote:FireServer("Claw Slash") end,
    m1 = function()
        remotes.remote:FireServer("NormalAttack")
        -- activar redirección temporal SOLAMENTE si el toggle persistente lo permite
        if Config.redirectEnabled then
        redirectUntil = tick() + 10  -- 10 segundos desde AHORA
    end
    end,

    hammer = function() remotes.toolremote:FireServer("Blood Hammer Slam") end,
}

-- =====================
-- State
-- =====================
local recentReactions = {}
local connections = {}

-- =====================
-- Lock-on internals
-- =====================
local camera = workspace.CurrentCamera
local targetPlayer = nil
local isLockOnActive = false
local lockSource = nil -- "manual" or "auto" or nil

-- backup para restaurar manual si un auto lo sobreescribe temporalmente
local lockBackup = {
    manual = nil,        -- { target = <Player> } si hay manual guardado
    currentAutoId = 0,   -- id para evitar race conditions entre autos
}

local function resetCameraSubject()
    task.spawn(function()
        pcall(function()
            local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                camera.CameraSubject = nil
                task.wait()
                camera.CameraSubject = humanoid
            end
        end)
    end)
end

local function setLockState(active, foundPlayer, source)
    -- source: "manual" or "auto" or nil
    if active then
        -- resolver Player desde Model si es necesario
        local playerInstance = nil
        if typeof(foundPlayer) == "Instance" then
            if foundPlayer:IsA("Player") then
                playerInstance = foundPlayer
            elseif foundPlayer:IsA("Model") then
                playerInstance = Players:GetPlayerFromCharacter(foundPlayer)
            end
        end
        if not playerInstance then
            -- nothing to lock to
            return
        end

        if source == "auto" and isLockOnActive and lockSource == "manual" then
            -- auto PREVALECE temporalmente: guarda el manual actual para restaurarlo luego
            lockBackup.manual = { target = targetPlayer }
        end

        if source == "manual" then
            -- si se activa manual mientras hay un auto, consideramos que el manual
            -- es ahora el principal y no queremos restaurar un manual viejo después.
            lockBackup.manual = nil
        end

        targetPlayer = playerInstance
        isLockOnActive = true
        lockSource = source or lockSource or "auto"
    else
        -- deactivation rules:
        if source == "manual" then
            -- manual deactivation always wins: borra todo (incluido backup)
            isLockOnActive = false
            targetPlayer = nil
            lockSource = nil
            lockBackup.manual = nil
            -- invalidar cualquier auto pendiente (evita que un callback antiguo lo restaure)
            lockBackup.currentAutoId = lockBackup.currentAutoId + 1
            resetCameraSubject()
        else
            -- auto deactivation only if lock was set by auto
            if lockSource == "auto" then
                -- si tenemos un manual guardado, lo restauramos
                if lockBackup.manual and lockBackup.manual.target then
                    local prev = lockBackup.manual.target
                    -- verificar que prev todavía sea un player válido
                    local ok = pcall(function() end)
                    targetPlayer = prev
                    isLockOnActive = true
                    lockSource = "manual"
                    lockBackup.manual = nil
                    -- no reseteamos cámara (seguimos lock con el manual restaurado)
                else
                    -- no hay manual guardado: limpiar todo
                    isLockOnActive = false
                    targetPlayer = nil
                    lockSource = nil
                    resetCameraSubject()
                end
            end
            -- if lockSource == "manual", ignore auto-deactivation (no cambia nada)
        end
    end
end

local function findClosestMatch(name)
    if not name or name == "" then return nil end
    name = name:lower()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name:lower():sub(1, #name) == name then
            return player
        end
    end
    return nil
end

local function activateLockManual(name, duration)
    if not name or name == "" then return end
    local found = findClosestMatch(name)
    if not found then return end
    setLockState(true, found, "manual")
    if duration and duration > 0 then
        -- schedule manual deactivation (but manual deactivation can still clear it earlier)
        task.delay(duration, function()
            setLockState(false, nil, "manual")
        end)
    end
end

local function activateLockAutoByPlayer(actorInstance, duration)
    if not actorInstance then return end
    local targetP = nil
    if actorInstance:IsA("Player") then
        targetP = actorInstance
    elseif actorInstance:IsA("Model") then
        targetP = Players:GetPlayerFromCharacter(actorInstance)
    end
    if not targetP then return end

    -- asignar id único para este auto (evita race entre varios autos)
    lockBackup.currentAutoId = lockBackup.currentAutoId + 1
    local myAutoId = lockBackup.currentAutoId

    -- si hay un manual activo, se guardará dentro de setLockState al entrar con source="auto"
    setLockState(true, targetP, "auto")

    -- programar desactivación solo si este auto sigue siendo el actual
    task.delay(duration or 1.3, function()
        if lockBackup.currentAutoId == myAutoId then
            setLockState(false, nil, "auto")
        end
    end)
end

local function deactivateLock()
    setLockState(false, nil, "manual")
end

RunService.RenderStepped:Connect(function()
    if isLockOnActive and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        local targetRoot = targetPlayer.Character.HumanoidRootPart

        local targetPos = targetRoot.Position
        local selfPos = root.Position
        local dir = Vector3.new(targetPos.X - selfPos.X, 0, targetPos.Z - selfPos.Z)
        if dir.Magnitude > 0 then
            local lookCFrame = CFrame.new(selfPos, selfPos + dir.Unit)
            local _, y, _ = lookCFrame:ToOrientation()
            root.CFrame = CFrame.new(selfPos) * CFrame.Angles(0, y, 0)
        end

        local camPos = root.Position + (root.CFrame:VectorToWorldSpace(Config.cameraOffset))
        camera.CFrame = CFrame.new(camPos, targetRoot.Position)
    else
        if isLockOnActive then
            -- if target lost, clear regardless of source (mantengo comportamiento actual)
            setLockState(false, nil, "manual")
        end
    end
end)

-- =====================
-- Reaction validation + execution
-- =====================






local function getEffectiveKey(id, originalKey)
    local now = tick()
    local redirectActiveNow = (now <= redirectUntil)

    if redirectActiveNow
       and (originalKey == "R" or originalKey == "E")
       and Config.redirectAnimations
       and Config.redirectAnimations[id] then
        return "F"
    end
    return originalKey
end




 local function isValidReaction(player, id, distance, isLocal, enemyHRP, cfg)
    if not cfg then return false end

    -- manejo claro de localAllowed:
    -- Por defecto (nil) no permitimos animaciones locales.
    -- Solo permitimos locales si cfg.localAllowed == true.
    if isLocal and not (cfg.localAllowed == true) then
        return false
    end

    if not LocalPlayer or not LocalPlayer.Character then return false end
    local HRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not HRP or not HRP.Parent then return false end
    if not enemyHRP or not enemyHRP.Parent then return false end

    -- rango (defaults seguros)
    local rmin = (cfg.range and cfg.range.min) or 0
    local rmax = (cfg.range and cfg.range.max) or math.huge
    if distance < rmin or distance > rmax then return false end

    -- estado humano / hybrid (usa isPlayerHybrid sobre el actor 'player' pasado)
    if cfg.state then
        local hybrid = isPlayerHybrid()
        if cfg.state == "hybrid" and not hybrid then return false end
        if cfg.state == "human" and hybrid then return false end
    end

    -- PARCHE DE COOLDOWN (igual que tu versión antigua)
    local identifier = "unknown"
    if typeof(player) == "Instance" then
        if player:IsA("Player") then
            identifier = "PLR_" .. tostring(player.UserId)
        elseif player:IsA("Model") then
            identifier = "NPC_" .. (player.Name or "Unnamed")
        else
            identifier = "OBJ_" .. player.ClassName
        end
    else
        identifier = tostring(player)
    end
    local key = identifier .. ":" .. tostring(id)
    if recentReactions[key] and tick() - recentReactions[key] < (cfg.delay or 0) then
        return false
    end

    -- visión angular
    if cfg.rv ~= false and distance >= 2 then
        local maxAngle = Config.getMaxAngleForDistance(distance)
        local enemyLookVector = enemyHRP.CFrame.LookVector
        local dirVec = HRP.Position - enemyHRP.Position
        if dirVec.Magnitude ~= 0 then
            local directionToMe = dirVec.Unit
            local dot = clamp(enemyLookVector:Dot(directionToMe), -1, 1)
            local angleDegrees = math.deg(math.acos(dot))
            if angleDegrees > maxAngle then
                return false
            end
        end
    end

    return true
end
local function react(playerObj, id, cfg)
    if not cfg then return end
    local keyToUse = getEffectiveKey(id, cfg.key or cfg.reaction)

    local identifier = makeIdentifier(playerObj)
    local reactionKey = identifier .. ":" .. tostring(id)
    recentReactions[reactionKey] = tick()

    task.delay(cfg.delay or 0, function()
        if keyToUse == "lock" or cfg.reaction == "lock" then
            -- new: lock uses the actor (playerObj) as the lock target
            local actor = playerObj
            local actorPlayer = nil
            if typeof(actor) == "Instance" then
                if actor:IsA("Player") then
                    actorPlayer = actor
                elseif actor:IsA("Model") then
                    actorPlayer = Players:GetPlayerFromCharacter(actor)
                end
            end
            if actorPlayer then
                activateLockAutoByPlayer(actorPlayer, cfg.lockDuration or 1.3)
            else
                -- fallback: if cfg.lockName explicitly provided, use manual activation by name
                local nameArg = (cfg.lockName and type(cfg.lockName) == "string" and cfg.lockName ~= "") and cfg.lockName or nil
                if nameArg then
                    activateLockManual(nameArg, cfg.lockDuration or 1.3)
                end
            end
            return
        end

        local action = keyActions[keyToUse]
        if action then
            action()
        else
            warn("No hay acción para la key:", tostring(keyToUse), "en id", id)
        end
    end)
end

-- =====================
-- Animation handler
-- =====================
local function onAnimationPlayed(track, owner, isLocal, playerObj)
    if not Config.autoParryEnabled then return end
    if not track or not track.Animation or not track.Animation.AnimationId then return end

    local id = track.Animation.AnimationId:match("%d+")
    if not id then return end

    local character = getCharacterFromOwner(owner)
    if not character then return end


    -- >>> NUEVO: si es mi anim local y es una M1, activar redirect temporal
if isLocal and Config.m1AnimationIds[id] and Config.redirectEnabled then
    redirectUntil = tick() + 10
end

    -- <<< fin nuevo bloque

    local targetHRP = character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end

    local ok, distance = pcall(function()
        return (LocalPlayer.Character.HumanoidRootPart.Position - targetHRP.Position).Magnitude
    end)
    if not ok or not distance then return end

    local Configs = animationReactions[id]
    if not Configs then return end

    local list = {}
    if type(Configs) == "table" and Configs[1] then
        for _, v in ipairs(Configs) do table.insert(list, v) end
    else
        table.insert(list, Configs)
    end

        local filtered = {}
    for _, cfg in ipairs(list) do
        if cfg.disabled then
            -- skip
        elseif cfg.autoAttack and not Config.autoAttackEnabled then
            -- skip auto-attack while feature off
        elseif cfg.parrykick and not Config.autoParryKickEnabled then
            -- skip parrykick (m1 localAllowed) while feature off
        else
            table.insert(filtered, cfg)
        end
    end

    if #filtered == 0 then return end

    local valid = {}
    for _, cfg in ipairs(filtered) do
        if isValidReaction(playerObj or character, id, distance, isLocal, targetHRP, cfg) then
            table.insert(valid, cfg)
        end
    end
    if #valid == 0 then return end

    table.sort(valid, function(a, b) return (a.priority or 0) > (b.priority or 0) end)
    for _, v in ipairs(valid) do react(playerObj or character, id, v) end
end

-- =====================
-- Monitorizado y limpieza (jugadores / NPCs / Animators)
-- =====================
local function disconnectList(list)
    if not list then return end
    for _, c in ipairs(list) do
        if c and c.Disconnect then
            pcall(function() c:Disconnect() end)
        end
    end
end

local function cleanupKey(key)
    if connections[key] then
        disconnectList(connections[key].animConns)
        if connections[key].childAddedConn then pcall(function() connections[key].childAddedConn:Disconnect() end) end
        if connections[key].ancestryConn then pcall(function() connections[key].ancestryConn:Disconnect() end) end
        connections[key] = nil
    end
end

local function connectAnimatorToPlayer(key, character, animator, playerObj, isLocal)
    if not animator or not animator:IsA("Animator") then return end
    if animator.Parent and animator.Parent:IsA("Humanoid") then return end

    local conn = animator.AnimationPlayed:Connect(function(track)
        onAnimationPlayed(track, character, isLocal, playerObj)
    end)
    connections[key].animConns = connections[key].animConns or {}
    table.insert(connections[key].animConns, conn)
end

local function monitorCharacter(playerObj, character, isLocal)
    if not playerObj or not character then return end
    local key = makeIdentifier(playerObj)

    cleanupKey(key)

    connections[key] = connections[key] or {}
    connections[key].animConns = {}

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local hconn = humanoid.AnimationPlayed:Connect(function(track)
            onAnimationPlayed(track, humanoid, isLocal, playerObj)
        end)
        table.insert(connections[key].animConns, hconn)
    end

    for _, obj in ipairs(character:GetDescendants()) do
        if obj:IsA("AnimationController") then
            local anim = obj:FindFirstChild("Animator")
            if anim then connectAnimatorToPlayer(key, character, anim, playerObj, isLocal) end
        elseif obj:IsA("Animator") then
            connectAnimatorToPlayer(key, character, obj, playerObj, isLocal)
        end
    end

    connections[key].childAddedConn = character.ChildAdded:Connect(function(child)
        if child:IsA("AnimationController") then
            local anim = child:FindFirstChild("Animator") or child:WaitForChild("Animator", 2)
            if anim then connectAnimatorToPlayer(key, character, anim, playerObj, isLocal) end
        elseif child:IsA("Animator") then
            connectAnimatorToPlayer(key, character, child, playerObj, isLocal)
        else
            task.defer(function()
                for _, d in ipairs(child:GetDescendants()) do
                    if d:IsA("AnimationController") then
                        local a = d:FindFirstChild("Animator")
                        if a then connectAnimatorToPlayer(key, character, a, playerObj, isLocal) end
                    elseif d:IsA("Animator") then
                        connectAnimatorToPlayer(key, character, d, playerObj, isLocal)
                    end
                end
            end)
        end
    end)

    connections[key].ancestryConn = character.AncestryChanged:Connect(function(_, parent)
        if not parent then
            cleanupKey(key)
        end
    end)
end

-- NPC monitor (workspace.Living)
local function monitorNPC(npc)
    if not npc or not npc:IsA("Model") then return end
    local npcName = npc.Name
    if not (string.find(npcName, "Fiend") or string.find(npcName, "Devil") or string.find(npcName, "Yakuza") or string.find(npcName, "Hunter") or string.find(npcName, "Guy") or string.find(npcName, "Zombie")) then return end

    local key = "NPC_" .. npcName
    cleanupKey(key)
    connections[key] = connections[key] or {}
    connections[key].animConns = {}

    local humanoid = npc:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local conn = humanoid.AnimationPlayed:Connect(function(track)
            onAnimationPlayed(track, npc, false, npc)
        end)
        table.insert(connections[key].animConns, conn)
    end

    for _, obj in ipairs(npc:GetDescendants()) do
        if obj:IsA("AnimationController") then
            local anim = obj:FindFirstChild("Animator")
            if anim then
                local conn = anim.AnimationPlayed:Connect(function(track)
                    onAnimationPlayed(track, npc, false, npc)
                end)
                table.insert(connections[key].animConns, conn)
            end
        end
    end

    connections[key].ancestryConn = npc.AncestryChanged:Connect(function(_, parent)
        if not parent then cleanupKey(key) end
    end)
end

-- =====================
-- Conexiones iniciales
-- =====================
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        if player.Character then monitorCharacter(player, player.Character, false) end
        player.CharacterAdded:Connect(function(char)
            task.wait(1)
            monitorCharacter(player, char, false)
        end)
    end
end

local LivingFolder = workspace:WaitForChild("Living")
for _, npc in ipairs(LivingFolder:GetChildren()) do monitorNPC(npc) end
LivingFolder.ChildAdded:Connect(function(npc) task.wait(0.5) monitorNPC(npc) end)

Players.PlayerAdded:Connect(function(player)
    if player == LocalPlayer then return end
    player.CharacterAdded:Connect(function(char) task.wait(1) monitorCharacter(player, char, false) end)
    if player.Character then monitorCharacter(player, player.Character, false) end
end)

Players.PlayerRemoving:Connect(function(player)
    cleanupKey(makeIdentifier(player))
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    monitorCharacter(LocalPlayer, char, true)
end)

if LocalPlayer.Character then monitorCharacter(LocalPlayer, LocalPlayer.Character, true) end


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local remoteEvent = ReplicatedStorage:WaitForChild("events"):WaitForChild("remote")

local autoDashEnabled = false
local isDashing = false
local dashDelay = 0.1
local idleThreshold = 1

local currentHRP = nil

local function fireDash()
    local args = { "Dash", "" }
    remoteEvent:FireServer(unpack(args))
end

local function isIdle()
    if not currentHRP then return false end
    return currentHRP.Velocity.Magnitude < idleThreshold
end

RunService.Heartbeat:Connect(function()
    if not autoDashEnabled then return end
    if not currentHRP then return end

    if isIdle() and not isDashing then
        isDashing = true
        task.spawn(function()
            while isDashing and isIdle() and autoDashEnabled do
                fireDash()
                task.wait(dashDelay)
            end
            isDashing = false
        end)
    elseif not isIdle() then
        isDashing = false
    end
end)

local function updateCharacterReferences()
    local character = player.Character or player.CharacterAdded:Wait()
    currentHRP = character:WaitForChild("HumanoidRootPart")
end

player.CharacterAdded:Connect(updateCharacterReferences)

updateCharacterReferences()

-- <<< ESTA VARIABLE LA LEERÁ RAYFIELD >>>
_G.AutoDashEnabled = function(state)
    autoDashEnabled = state
end

-- =====================
-- Exports: Config y API (para que el GUI o módulos externos controlen el script)
-- =====================

_G.AutoParryConfig = Config
_G.AutoParryAnimationReactions = animationReactions

-- Asegurar el namespace API antes de asignar funciones (importantísimo)
_G.AutoParryAPI = _G.AutoParryAPI or {}

_G.AutoParryAPI.SetRedirectEnabled = function(val) Config.redirectEnabled = not not val end
_G.AutoParryAPI.IsRedirectEnabled = function() return Config.redirectEnabled end

_G.AutoParryAPI.ActivateLock = function(name, duration) activateLockManual(name, duration) end
_G.AutoParryAPI.DeactivateLock = function() deactivateLock() end
_G.AutoParryAPI.SetAutoParry = function(val) Config.autoParryEnabled = not not val end
_G.AutoParryAPI.SetCameraOffset = function(vec3) if typeof(vec3) == "Vector3" then Config.cameraOffset = vec3 end end
_G.AutoParryAPI.SetReactionDisabled = function(animId, disabled)
    if not animId then return end
    local cfg = animationReactions[tostring(animId)]
    if cfg then
        if type(cfg) == "table" and cfg[1] then
            for _, v in ipairs(cfg) do v.disabled = disabled and true or nil end
        else
            cfg.disabled = disabled and true or nil
        end
    end
end
_G.AutoParryAPI.SetReactionAutoAttack = function(animId, isAuto)
    if not animId then return end
    local cfg = animationReactions[tostring(animId)]
    if cfg then
        if type(cfg) == "table" and cfg[1] then
            for _, v in ipairs(cfg) do v.autoAttack = isAuto and true or nil end
        else
            cfg.autoAttack = isAuto and true or nil
        end
    end
end
_G.AutoParryAPI.SetParryKick = function(val)
    Config.autoParryKickEnabled = not not val
end

_G.AutoParryAPI.GetEditableReactionIds = function()
    local out = {}
    for id, cfg in pairs(animationReactions) do
        local editable = false
        if type(cfg) == "table" and cfg.editable then editable = true end
        if type(cfg) == "table" and cfg[1] then
            for _, v in ipairs(cfg) do if v.editable then editable = true break end end
        end
        if editable then table.insert(out, id) end
    end
    return out
end

-- Fin del LocalScript
-- Projectile Parry Helper (LocalScript) - actualizado
-- Detecta proyectiles (AirSlash / BloodSpear / SawBlade) y activa Parry (F) o Dash (Q)
-- Añadido: matchers robustos y minRadius (distancia mínima) que marca proyectiles como ignorados si aparecen demasiado cerca.

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

local eventsFolder = ReplicatedStorage:WaitForChild("events")
local remotes = {
    remote = eventsFolder:WaitForChild("remote"),
    toolremote = eventsFolder:WaitForChild("toolremote"),
}

local ProjectileParry = {
    enabled = true,
    -- Per-type config (radius = trigger distance, minRadius = ignore if too close upon detection)
    types = {
        AirSlash = {
            name = "AirSlash",
            matcher = function(inst)
                local name = tostring(inst.Name):lower()
                if name:find("airslash") then return true end
                -- buscar ancestros (folder/model) que contengan "airslash"
                local p = inst.Parent
                while p do
                    if tostring(p.Name):lower():find("airslash") then return true end
                    p = p.Parent
                end
                return false
            end,
            radius = 37,
            minRadius = 10, -- si quieres ignorar por estar demasiado cerca usa >0, p.ej. 2 o 8
            minExistence = 0, 
            key = "F",
            debounce = 0.3,
            enabled = true,
        },
        BloodSpear = {
            name = "BloodSpear",
            matcher = function(inst)
                -- queremos detectar exactamente el Mesh dentro de BloodSpear:
                -- workspace.EFFECT.BloodSpear.Mesh
                if not inst then return false end
                -- si el objeto es una BasePart y su nombre es "Mesh" y su padre es "BloodSpear"
                if inst:IsA("BasePart") and tostring(inst.Name) == "Mesh" and inst.Parent and tostring(inst.Parent.Name) == "BloodSpear" then
                    return true
                end
                -- si es un SpecialMesh (u otro) llamado "Mesh" dentro de una part llamada BloodSpear
                if tostring(inst.Name) == "Mesh" and inst.Parent and inst.Parent:IsA("BasePart") and inst.Parent.Parent and tostring(inst.Parent.Parent.Name) == "BloodSpear" then
                    return true
                end
                return false
            end,
            radius = 45,
            minRadius = 10,
            minExistence = 0.4,
            key = "F",
            debounce = 0.3,
            enabled = true,
        },

        SawBlade = {
           name = "SawBlade",
           -- MATCHER ESTRICTO: detecta el Attachment llamado "Attachment" dentro de la parte "SawBlade"
           matcher = function(inst)
               if not inst then return false end
               -- si es Attachment y su parent se llama "SawBlade"
               if inst:IsA("Attachment") and tostring(inst.Name) == "Attachment" and inst.Parent and tostring(inst.Parent.Name) == "SawBlade" then
                   return true
               end
               -- fallback estricto: si es la parte "SawBlade" (por compatibilidad), permitimos también
               if inst:IsA("BasePart") and tostring(inst.Name) == "SawBlade" then
                   -- preferimos el Attachment si existe, pero aún así devolvemos true para watchear la parte
                   return true
               end
               return false
           end,
           radius = 45,
           minRadius = 10,
           minExistence = 0,
           key = "F",
           debounce = 0.3,
           enabled = true,
        },


    },

getPositionFromInstance = function(inst)
    if not inst then return nil end

    -- Solo operar si es una Instance válida
    if typeof(inst) == "Instance" then
        -- Attachment: usamos WorldPosition (útil para SawBlade.Attachment)
        if inst:IsA("Attachment") then
            local ok, pos = pcall(function() return inst.WorldPosition end)
            if ok and pos then return pos end
        end

        -- Si es un BasePart (Part, MeshPart, etc.)
        if inst:IsA("BasePart") then
            return inst.Position
        end

        -- SpecialMesh: tomar la posición de su parent si es BasePart
        if inst:IsA("SpecialMesh") then
            local p = inst.Parent
            if p and typeof(p) == "Instance" and p:IsA("BasePart") then return p.Position end
        end

        -- Si es Model: PrimaryPart o primer BasePart descendiente
        if inst:IsA("Model") then
            if inst.PrimaryPart and typeof(inst.PrimaryPart) == "Instance" and inst.PrimaryPart:IsA("BasePart") then
                return inst.PrimaryPart.Position
            end
            -- usar pcall por seguridad si la API falla por algún motivo
            if inst.FindFirstChildWhichIsA then
                local ok, bp = pcall(function() return inst:FindFirstChildWhichIsA("BasePart", true) end)
                if ok and bp then return bp.Position end
            end
        end
    end

    -- Fallback: intentar usar FindFirstChildWhichIsA si existe en el objeto (cualquier otro tipo)
    if inst and inst.FindFirstChildWhichIsA then
        local ok, bp = pcall(function() return inst:FindFirstChildWhichIsA("BasePart", true) end)
        if ok and bp then return bp.Position end
    end

    return nil
end,



}

local tracked = {} -- tracked[instance] = {typeName, lastTriggered, conn, ignoredDueToTooClose}
local lastCleanup = 0

-- helpers mínimos que faltaban (pegarlos antes de scanAndHook)
local scannedInitial = false

local function dbg(...)
    -- simple logger que puedes activar/desactivar cambiando ProjectileParry.debug
    if ProjectileParry and ProjectileParry.debug then
        local args = {...}
        for i=1,#args do args[i] = tostring(args[i]) end
        warn("[ProjectileParry DEBUG] "..table.concat(args, " "))
    end
end

local function makePath(inst)
    local parts = {}
    local cur = inst
    pcall(function()
        while cur do
            table.insert(parts, 1, tostring(cur.Name))
            cur = cur.Parent
        end
    end)
    return table.concat(parts, "/")
end


local function performKeyAction(key)
    if key == "F" then
        pcall(function() remotes.remote:FireServer("Parry") end)
    elseif key == "Q" then
        pcall(function() remotes.remote:FireServer("Dash", "W", "NoTorsoRotate") end)
    else
        if _G and _G.AutoParryAPI and _G.AutoParryAPI.KeyAction then
            pcall(function() _G.AutoParryAPI.KeyAction(key) end)
        end
    end
end


local function watchInstance(inst, typeName, cfg)
    if not inst or not inst.Parent then return end
    if tracked[inst] then return end

    local data = {
        typeName = typeName,
        lastTriggered = 0,
        ignoredDueToTooClose = false,
        conn = nil,
        detectedAt = tick(),   -- cuando lo detectamos
        checkedTooClose = false, -- para evaluar minRadius solo una vez
        triggeredOnce = false,
    }
    tracked[inst] = data

    dbg("WATCH added:", typeName, makePath(inst), "detectedAt="..tostring(data.detectedAt))

    local conn
    conn = RunService.Heartbeat:Connect(function()
        -- cleanup if destroyed
        if not inst or not inst.Parent then
            dbg("WATCH cleanup (destroyed):", typeName, makePath(inst))
            if conn then pcall(function() conn:Disconnect() end) end
            tracked[inst] = nil
            return
        end

        if not ProjectileParry.enabled then return end
        if not cfg.enabled then return end
        if _G and _G.AutoParryConfig and not _G.AutoParryConfig.autoParryEnabled then return end

        local projPos = ProjectileParry.getPositionFromInstance(inst)
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not projPos or not hrp then
            -- throttle: log solo cada cierto tiempo por instancia
            if ProjectileParry.debug then
                data._lastNoPosLog = data._lastNoPosLog or 0
                if tick() - data._lastNoPosLog >= 1.5 then
                    data._lastNoPosLog = tick()
                    dbg("Skipping check (no projPos or no hrp):", typeName, makePath(inst))
                end
            end
            return
        end

        local distance = (projPos - hrp.Position).Magnitude

        -- check minRadius ONCE (si al detectarlo estaba demasiado cerca)
        if not data.checkedTooClose then
            data.checkedTooClose = true
            if cfg.minRadius and cfg.minRadius > 0 then
                if distance <= cfg.minRadius then
                    data.ignoredDueToTooClose = true
                    data.ignoredMarkedAt = tick()
                    dbg("Ignored (too close at detection):", typeName, makePath(inst),
                        "distance="..string.format("%.2f", distance),
                        "minRadius="..tostring(cfg.minRadius))
                    return
                end
            end
        end

        if data.ignoredDueToTooClose then
            if ProjectileParry.debug and (tick() - (data._lastIgnoreLog or 0) > 2) then
                data._lastIgnoreLog = tick()
                dbg("Still ignoredDueToTooClose:", typeName, makePath(inst))
            end
            return
        end

        -- Evitar más de una reacción por proyectil (si ya fue triggeredOnce, ignorar)
        if data.triggeredOnce then
            return
        end

        -- comprobar minExistence: no reaccionar si el proyectil es "muy nuevo"
        local now = tick()
        local minExist = (cfg.minExistence ~= nil) and cfg.minExistence or 0
        if now - data.detectedAt < minExist then
            if ProjectileParry.debug and (now - (data._lastExistenceLog or 0) > 0.1) then
                data._lastExistenceLog = now
                dbg("Waiting minExistence:", typeName, makePath(inst),
                    "age="..string.format("%.3f", now - data.detectedAt),
                    "need="..tostring(minExist))
            end
            return
        end

        -- normal trigger when inside radius
        if distance <= cfg.radius then
            if ProjectileParry.debug then
                dbg("Inside radius:", typeName, makePath(inst),
                    "distance="..string.format("%.2f", distance),
                    "radius="..tostring(cfg.radius))
            end
            if (cfg.debounce or 0) <= 0 then
                data.triggeredOnce = true
                performKeyAction(cfg.key)
                dbg("Triggered action immediate:", cfg.key, "for", typeName, makePath(inst))
            else
                if now - data.lastTriggered >= (cfg.debounce or 0) then
                    data.lastTriggered = now
                    data.triggeredOnce = true
                    performKeyAction(cfg.key)
                    dbg("Triggered action (debounced):", cfg.key, "for", typeName, makePath(inst))
                else
                    if ProjectileParry.debug then
                        dbg("Debounce prevents trigger:", typeName, makePath(inst),
                            "elapsed="..string.format("%.2f", now - data.lastTriggered),
                            "needed="..tostring(cfg.debounce))
                    end
                end
            end
        else
            if ProjectileParry.debug and (now - (data._lastDistanceLog or 0) > 0.5) then
                data._lastDistanceLog = now
                dbg("Proj distance (not in radius):", typeName, makePath(inst),
                    "distance="..string.format("%.2f", distance),
                    "radius="..tostring(cfg.radius))
            end
        end
    end)

    data.conn = conn
end


-- Reemplaza la función scanAndHook() y los hooks por esto:

local function scanAndHook()
    if scannedInitial then return end
    scannedInitial = true

    dbg("Scanning workspace (targeted) for projectiles (initial) ...")

    -- 1) AirSlash: buscar solo entre children directos de workspace
    local airCfg = ProjectileParry.types["AirSlash"]
    if airCfg then
        for _, inst in ipairs(workspace:GetChildren()) do
            pcall(function()
                if airCfg.matcher(inst) then
                    dbg("Matcher TRUE (initial - workspace child): AirSlash ->", makePath(inst))
                    watchInstance(inst, "AirSlash", airCfg)
                end
            end)
        end
    end

    -- 2) EFFECT folder: buscar solo dentro de workspace.EFFECT (descendientes)
    local effectFolder = workspace:FindFirstChild("EFFECT") or workspace:FindFirstChild("Effect") -- por si usan mayúscula distinta
    if effectFolder then
        dbg("Found EFFECT folder:", makePath(effectFolder))
        for _, inst in ipairs(effectFolder:GetDescendants()) do
            for typeName, cfg in pairs(ProjectileParry.types) do
                if typeName ~= "AirSlash" then
                    pcall(function()
                        if cfg.matcher(inst) then
                            dbg("Matcher TRUE (initial - EFFECT):", typeName, makePath(inst))
                            watchInstance(inst, typeName, cfg)
                        end
                    end)
                end
            end
        end
    else
        dbg("No EFFECT folder found at workspace.EFFECT. BloodSpear/SawBlade won't be auto-scanned until folder exists.")
    end

    -- HOOKS: events limitados (NO global DescendantAdded)
    --  a) workspace.ChildAdded -> para AirSlash (aparece como child directo)
    workspace.ChildAdded:Connect(function(inst)
        pcall(function()
            if airCfg and airCfg.matcher(inst) then
                dbg("Matcher TRUE (ChildAdded - workspace): AirSlash ->", makePath(inst))
                watchInstance(inst, "AirSlash", airCfg)
            end
        end)
    end)

    --  b) EFFECT.DescendantAdded -> para BloodSpear / SawBlade
    if effectFolder then
        effectFolder.DescendantAdded:Connect(function(inst)
            for typeName, cfg in pairs(ProjectileParry.types) do
                if typeName ~= "AirSlash" then
                    pcall(function()
                        if cfg.matcher(inst) then
                            dbg("Matcher TRUE (DescendantAdded - EFFECT):", typeName, makePath(inst))
                            watchInstance(inst, typeName, cfg)
                        end
                    end)
                end
            end
        end)
    end
end

-- Llamarla como antes
scanAndHook()


RunService.Heartbeat:Connect(function()
    if tick() - lastCleanup > 10 then
        lastCleanup = tick()
        for inst, data in pairs(tracked) do
            if not inst or not inst.Parent then
                if data.conn then pcall(function() data.conn:Disconnect() end) end
                tracked[inst] = nil
            end
        end
    end
end)

-- API
_G.AutoParryProjectileAPI = _G.AutoParryProjectileAPI or {}

_G.AutoParryProjectileAPI.SetEnabled = function(val) ProjectileParry.enabled = not not val end
_G.AutoParryProjectileAPI.IsEnabled = function() return ProjectileParry.enabled end

_G.AutoParryProjectileAPI.SetTypeEnabled = function(typeName, val)
    if ProjectileParry.types[typeName] then ProjectileParry.types[typeName].enabled = not not val end
end
_G.AutoParryProjectileAPI.SetTypeRadius = function(typeName, radius)
    if ProjectileParry.types[typeName] and type(radius) == "number" then ProjectileParry.types[typeName].radius = radius end
end
_G.AutoParryProjectileAPI.SetTypeMinRadius = function(typeName, minr)
    if ProjectileParry.types[typeName] and type(minr) == "number" then ProjectileParry.types[typeName].minRadius = minr end
end
_G.AutoParryProjectileAPI.SetTypeKey = function(typeName, key)
    if ProjectileParry.types[typeName] and (key == "F" or key == "Q") then ProjectileParry.types[typeName].key = key end
end
_G.AutoParryProjectileAPI.SetTypeDebounce = function(typeName, s)
    if ProjectileParry.types[typeName] and type(s) == "number" then ProjectileParry.types[typeName].debounce = s end
end
_G.AutoParryProjectileAPI.GetTracked = function() return tracked end
_G.AutoParryProjectileAPI.ForceClearIgnored = function(inst) if tracked[inst] then tracked[inst].ignoredDueToTooClose = false end end

print("[ProjectileParry] listo: matchers actualizados y minRadius implementado.")

-- Rayfield integration for AutoParry
-- Pegar este script en un LocalScript separado (después de cargar la librería Rayfield)
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Configuración de la ventana
local Window = Rayfield:CreateWindow({
   Name = "AutoParry Hub",
   LoadingTitle = "AutoParry Hub",
   LoadingSubtitle = "by Dylan(aka borrencsmdh)",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = "DaniHubs",
      FileName = "AutoParryConfig"
   },
   ToggleUIKeybind = "K",
})

-- Tabs
local mainTab = Window:CreateTab("Main", "shield")
local reactionsTab = Window:CreateTab("Reactions", "list")
local cameraTab = Window:CreateTab("Camera", "move")
local miscTab = Window:CreateTab("Misc", "settings")

-- Helpers to read/write Config safely
local function getConfig() return _G.AutoParryConfig or {} end
local function setConfigField(k, v) 
    local C = getConfig()
    C[k] = v
    _G.AutoParryConfig = C
end

-- MAIN TAB
local autoToggle = mainTab:CreateToggle({
    Name = "Auto-parry",
    CurrentValue = getConfig().autoParryEnabled == true,
    Flag = "AutoParryToggle",
    Callback = function(value)
        setConfigField("autoParryEnabled", value)
        if _G.AutoParryAPI and _G.AutoParryAPI.SetAutoParry then
            _G.AutoParryAPI.SetAutoParry(value)
        end
    end,
})

local autoDashToggle = mainTab:CreateToggle({
    Name = "Auto Dash (Idle Dash)",
    CurrentValue = false,
    Flag = "AutoDash",
    Callback = function(value)
        _G.AutoDashEnabled(value)
        Rayfield:Notify({
            Title = "Auto Dash",
            Content = value and "Enabled" or "Disabled",
            Duration = 1.5
        })
    end,
})

local parryKickToggle = mainTab:CreateToggle({
    Name = "AutoParryKick Enabled",
    CurrentValue = getConfig().autoParryKickEnabled == true,
    Flag = "AutoParryKick",
    Callback = function(value)
        setConfigField("autoParryKickEnabled", value)
        Rayfield:Notify({Title = "AutoParryKick", Content = (value and "Enabled" or "Disabled"), Duration = 1.6})
    end,
})

local redirectToggle = mainTab:CreateToggle({
    Name = "Parry clash",
    CurrentValue = getConfig().redirectEnabled == true,
    Flag = "RedirectRtoF",
    Callback = function(value)
        setConfigField("redirectEnabled", value)
        if _G.AutoParryAPI and _G.AutoParryAPI.SetRedirectEnabled then
            _G.AutoParryAPI.SetRedirectEnabled(value)
        end
    end,
})


local activateLockInput = mainTab:CreateInput({
    Name = "Lock target name",
    CurrentValue = "",
    PlaceholderText = "Player name (start)",
    Flag = "LockNameInput",
    Callback = function(val) end,
})

local activateLockBtn = mainTab:CreateButton({
    Name = "Activate Lock",
    Callback = function()
        local name = activateLockInput.CurrentValue
        if name and name ~= "" and _G.AutoParryAPI and _G.AutoParryAPI.ActivateLock then
            _G.AutoParryAPI.ActivateLock(name, 999) -- lock 10s by default (ajustable)
            Rayfield:Notify({Title = "Lock", Content = "Lock activated: "..name, Duration = 3})
        else
            Rayfield:Notify({Title = "Lock", Content = "Invalid name or API not found", Duration = 3})
        end
    end,
})

local deactivateLockBtn = mainTab:CreateButton({
    Name = "Deactivate Lock",
    Callback = function()
        if _G.AutoParryAPI and _G.AutoParryAPI.DeactivateLock then
            _G.AutoParryAPI.DeactivateLock()
            Rayfield:Notify({Title = "Lock", Content = "Lock deactivated", Duration = 2})
        end
    end,
})

-- CAMERA TAB: control X, Y, Z offsets
local camOffset = getConfig().cameraOffset or Vector3.new(3,8,15)

local sx = cameraTab:CreateSlider({
   Name = "Camera Offset X (right)",
   Range = {-20, 20},
   Increment = 1,
   CurrentValue = camOffset.X,
   Flag = "CamOffsetX",
   Callback = function(value)
       local C = getConfig()
       C.cameraOffset = Vector3.new(value, C.cameraOffset.Y, C.cameraOffset.Z)
       setConfigField("cameraOffset", C.cameraOffset)
       if _G.AutoParryAPI and _G.AutoParryAPI.SetCameraOffset then _G.AutoParryAPI.SetCameraOffset(C.cameraOffset) end
   end,
})

local sy = cameraTab:CreateSlider({
   Name = "Camera Offset Y (up)",
   Range = {-20, 40},
   Increment = 1,
   CurrentValue = camOffset.Y,
   Flag = "CamOffsetY",
   Callback = function(value)
       local C = getConfig()
       C.cameraOffset = Vector3.new(C.cameraOffset.X, value, C.cameraOffset.Z)
       setConfigField("cameraOffset", C.cameraOffset)
       if _G.AutoParryAPI and _G.AutoParryAPI.SetCameraOffset then _G.AutoParryAPI.SetCameraOffset(C.cameraOffset) end
   end,
})

local sz = cameraTab:CreateSlider({
   Name = "Camera Offset Z (back)",
   Range = {-40, 40},
   Increment = 1,
   CurrentValue = camOffset.Z,
   Flag = "CamOffsetZ",
   Callback = function(value)
       local C = getConfig()
       C.cameraOffset = Vector3.new(C.cameraOffset.X, C.cameraOffset.Y, value)
       setConfigField("cameraOffset", C.cameraOffset)
       if _G.AutoParryAPI and _G.AutoParryAPI.SetCameraOffset then _G.AutoParryAPI.SetCameraOffset(C.cameraOffset) end
   end,
})

-- REACTIONS TAB: crea toggles dinámicos para cada id en animationReactions
-- REACTIONS TAB — crea toggles automáticamente para entries con editable = true

-- Global AutoAttack switch (controla todas las reacciones con autoAttack=true)
local globalAutoAttack = reactionsTab:CreateToggle({
    Name = "AutoAttack Reactions (global)",
    CurrentValue = getConfig().autoAttackEnabled == true,
    Flag = "GlobalAutoAttack",
    Callback = function(val)
        setConfigField("autoAttackEnabled", val)
        Rayfield:Notify({Title = "AutoAttack", Content = (val and "Enabled" or "Disabled"), Duration = 1.5})
    end,
})



-- MISC: quick actions and export
miscTab:CreateButton({
    Name = "Force Save Config Now",
    Callback = function()
        Rayfield:SaveConfiguration()
        Rayfield:Notify({Title = "Config", Content = "Saved", Duration = 1.8})
    end,
})

miscTab:CreateButton({
    Name = "Force Load Config Now",
    Callback = function()
        Rayfield:LoadConfiguration()
        Rayfield:Notify({Title = "Config", Content = "Loaded", Duration = 1.8})
    end,
})

-- Keybind to toggle AutoParry quickly
mainTab:CreateKeybind({
    Name = "Toggle AutoParry Key",
    CurrentKeybind = "P",
    HoldToInteract = false,
    Flag = "ToggleAPKey",
    Callback = function(Key)
        local cur = getConfig().autoParryEnabled
        setConfigField("autoParryEnabled", not cur)
        if _G.AutoParryAPI and _G.AutoParryAPI.SetAutoParry then
            _G.AutoParryAPI.SetAutoParry(not cur)
        end
        Rayfield:Notify({Title = "AutoParry", Content = (not cur and "Enabled" or "Disabled"), Duration = 1.5})
    end,
})

-- Important: expose animationReactions table to UI if possible (so toggles actually mutate the live table)
-- If tu LocalScript no lo exportó, te recomiendo añadir en ese LocalScript:
-- _G.AutoParryAnimationReactions = animationReactions
-- (esto permite que la UI modifique 'disabled' flags directamente)

-- Finalmente: load configuration so Rayfield restores values
Rayfield:LoadConfiguration()
